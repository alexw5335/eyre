
Codes            Mnemonic        Explanation

\0                                       terminates the code. (Unless it's a literal of course.)
\1..\4                                   that many literal bytes follow in the code stream
\5                                       add 4 to the primary operand number (b, low octdigit)
\6                                       add 4 to the secondary operand number (a, middle octdigit)
\7                                       add 4 to both the primary and the secondary operand number
\10..\13                                 a literal byte follows in the code stream, to be added
                                         to the register value of operand 0..3
\14..\17                                 the position of index register operand in MIB (BND insns)
\20..\23         ib                      a byte immediate operand, from operand 0..3
\24..\27         ib,u                    a zero-extended byte immediate operand, from operand 0..3
\30..\33         iw                      a word immediate operand, from operand 0..3
\34..\37         iwd                     select between \3[0-3] and \4[0-3] depending on 16/32 bit
                                         assembly mode or the operand-size override on the operand
\40..\43         id                      a long immediate operand, from operand 0..3
\44..\47         iwdq                    select between \3[0-3], \4[0-3] and \5[4-7]
                                         depending on the address size of the instruction.
\50..\53         rel8                    a byte relative operand, from operand 0..3
\54..\57         iq                      a qword immediate operand, from operand 0..3
\60..\63         rel16                   a word relative operand, from operand 0..3
\64..\67         rel                     select between \6[0-3] and \7[0-3] depending on 16/32 bit
                                         assembly mode or the operand-size override on the operand
\70..\73         rel32                   a long relative operand, from operand 0..3
\74..\77         seg                     a word constant, from the _segment_ part of operand 0..3
\1ab             /r                      a ModRM, calculated on EA in operand a, with the reg
                                         field the register value of operand b.
\171\mab         /mrb (e.g /3r0)         a ModRM, with the reg field taken from operand a, and the m
                                         and b fields set to the specified values.
\172\ab          /is4                    the register number from operand a in bits 7..4, with
                                         the 4-bit immediate from operand b in bits 3..0.
\173\xab                                 the register number from operand a in bits 7..4, with
                                         the value b in bits 3..0.
\174..\177                               the register number from operand 0..3 in bits 7..4, and
                                         an arbitrary value in bits 3..0 (assembled as zero.)
\2ab             /b                      a ModRM, calculated on EA in operand a, with the reg
                                         field equal to digit b.
\240..\243                               this instruction uses EVEX rather than REX or VEX/XOP, with the
                                         V field taken from operand 0..3.
\250                                     this instruction uses EVEX rather than REX or VEX/XOP, with the
                                         V field set to 1111b.


EVEX prefixes are followed by the sequence:
\cm\wlp\tup    where cm is:
                 cc 00m mmm
                 c = 2 for EVEX and mmmm is the M field (EVEX.P0[3:0])
               and wlp is:
                 00 wwl lpp
                 [l0]  ll = 0 (.128, .lz)
                 [l1]  ll = 1 (.256)
                 [l2]  ll = 2 (.512)
                 [lig] ll = 3 for EVEX.L'L don't care (always assembled as 0)

                 [w0]  ww = 0 for W = 0
                 [w1]  ww = 1 for W = 1
                 [wig] ww = 2 for W don't care (always assembled as 0)
                 [ww]  ww = 3 for W used as REX.W

                 [p0]  pp = 0 for no prefix
                 [60]  pp = 1 for legacy prefix 60
                 [f3]  pp = 2
                 [f2]  pp = 3

               tup is tuple type for Disp8*N from %tuple_codes in insns.pl
                   (compressed displacement encoding)

\254..\257       id,s                    a signed 32-bit operand to be extended to 64 bits.
\260..\263                               this instruction uses VEX/XOP rather than REX, with the
                                         V field taken from operand 0..3.
\270                                     this instruction uses VEX/XOP rather than REX, with the
                                         V field set to 1111b.
VEX/XOP prefixes are followed by the sequence:
\tmm\wlp        where mm is the M field; and wlp is:
                00 wwl lpp
                [l0]  ll = 0 for L = 0 (.128, .lz)
                [l1]  ll = 1 for L = 1 (.256)
                [lig] ll = 2 for L don't care (always assembled as 0)

                [w0]  ww = 0 for W = 0
                [w1 ] ww = 1 for W = 1
                [wig] ww = 2 for W don't care (always assembled as 0)
                [ww]  ww = 3 for W used as REX.W

t = 0 for VEX (C4/C5), t = 1 for XOP (8F).

\271             hlexr                       instruction takes XRELEASE (F3) with or without lock
\272             hlenl                       instruction takes XACQUIRE/XRELEASE with or without lock
\273             hle                         instruction takes XACQUIRE/XRELEASE with lock only
\274..\277       ib,s                        a byte immediate operand, from operand 0..3, sign-extended
                                             to the operand size (if o16/o32/o64 present) or the bit size
\310             a16                         indicates fixed 16-bit address size, i.e. optional 0x67.
\311             a32                         indicates fixed 32-bit address size, i.e. optional 0x67.
\312             adf                         (disassembler only) invalid with non-default address size.
\313             a64                         indicates fixed 64-bit address size, 0x67 invalid.
\314             norexb                      (disassembler only) invalid with REX.B
\315             norexx                      (disassembler only) invalid with REX.X
\316             norexr                      (disassembler only) invalid with REX.R
\317             norexw                      (disassembler only) invalid with REX.W
\320             o16                         indicates fixed 16-bit operand size, i.e. optional 0x66.
\321             o32                         indicates fixed 32-bit operand size, i.e. optional 0x66.
\322             odf                         indicates that this instruction is only valid when the
                                             operand size is the default (instruction to disassembler,
                                             generates no code in the assembler)
\323             o64nw                       indicates fixed 64-bit operand size, REX on extensions only.
\324             o64                         indicates 64-bit operand size requiring REX prefix.
\325             nohi                        instruction which always uses spl/bpl/sil/dil
\326             nof3                        instruction not valid with 0xF3 REP prefix.  Hint for
                                                disassembler only; for SSE instructions.
\331             norep                       instruction not valid with REP prefix.  Hint for
                                             disassembler only; for SSE instructions.
\332             f2i                         REP prefix (0xF2 byte) used as opcode extension.
\333             f3i                         REP prefix (0xF3 byte) used as opcode extension.
\334             rex.l                       LOCK prefix used as REX.R (used in non-64-bit mode)
\335             repe                        disassemble a rep (0xF3 byte) prefix as repe not rep.
\336             mustrep                     force a REP(E) prefix (0xF3) even if not specified.
\337             mustrepne                   force a REPNE prefix (0xF2) even if not specified.
                                             \336-\337 are still listed as prefixes in the disassembler.
\340             resb                        reserve <operand 0> bytes of uninitialized storage.
                                             Operand 0 had better be a segmentless constant.
\341             wait                        this instruction needs a WAIT "prefix"
\360             np                          no SSE prefix (== \364\331)
\361                                         66 SSE prefix (== \366\331)
\364             !osp                        operand-size prefix (0x66) not permitted
\365             !asp                        address-size prefix (0x67) not permitted
\366                                         operand-size prefix (0x66) used as opcode extension
\367                                         address-size prefix (0x67) used as opcode extension
\370,\371        jcc8                        match only if operand 0 meets byte jump criteria.
                 jmp8                        370 is used for Jcc, 371 is used for JMP.
\373             jlen                        assemble 0x03 if bits==16, 0x05 if bits==32;
                                             used for conditional jump over longer jump
\374             vsibx|vm32x|vm64x           this instruction takes an XMM VSIB memory EA
\375             vsiby|vm32y|vm64y           this instruction takes an YMM VSIB memory EA
\376             vsibz|vm32z|vm64z           this instruction takes an ZMM VSIB memory EA


if_("SM",                "Size match");
if_("SM2",               "Size match first two operands");
if_("SB",                "Unsized operands can't be non-byte");
if_("SW",                "Unsized operands can't be non-word");
if_("SD",                "Unsized operands can't be non-dword");
if_("SQ",                "Unsized operands can't be non-qword");
if_("SO",                "Unsized operands can't be non-oword");
if_("SY",                "Unsized operands can't be non-yword");
if_("SZ",                "Unsized operands can't be non-zword");
if_("SIZE",              "Unsized operands must match the bitsize");
if_("SX",                "Unsized operands not allowed");
if_("ANYSIZE",           "Ignore operand size even if explicit");
if_("AR0",               "SB, SW, SD applies to argument 0");
if_("AR1",               "SB, SW, SD applies to argument 1");
if_("AR2",               "SB, SW, SD applies to argument 2");
if_("AR3",               "SB, SW, SD applies to argument 3");
if_("AR4",               "SB, SW, SD applies to argument 4");
if_("OPT",               "Optimizing assembly only");
if_("LATEVEX",            "Only if EVEX instructions are disabled");

if_("PRIV",              "Privileged instruction");
if_("SMM",               "Only valid in SMM");
if_("PROT",              "Protected mode only");
if_("LOCK",              "Lockable if operand 0 is memory");
if_("NOLONG",            "Not available in long mode");
if_("LONG",              "Long mode");
if_("NOHLE",             "HLE prefixes forbidden");
if_("MIB",               "split base/index EA");      12, Only used with some MPX and AMXTILE instructions
if_("SIB",               "SIB encoding required");    3, Only used with AMXTILE instructions
if_("BND",               "BND (0xF2) prefix available");
if_("UNDOC",             "Undocumented");
if_("HLE",               "HLE prefixed");
if_("FPU",               "FPU");
if_("MMX",               "MMX");
if_("3DNOW",             "3DNow!");
if_("SSE",               "SSE (KNI, MMX2)");
if_("SSE2",              "SSE2");
if_("SSE3",              "SSE3 (PNI)");
if_("VMX",               "VMX");
if_("SSSE3",             "SSSE3");
if_("SSE4A",             "AMD SSE4a");
if_("SSE41",             "SSE4.1");
if_("SSE42",             "SSE4.2");
if_("SSE5",              "SSE5");
if_("AVX",               "AVX  (256-bit floating point)");
if_("AVX2",              "AVX2 (256-bit integer)");
if_("FMA",               "");
if_("BMI1",              "");
if_("BMI2",              "");
if_("TBM",               "");
if_("RTM",               "");
if_("INVPCID",           "");
if_("AVX512",            "AVX-512F (512-bit base architecture)");
if_("AVX512CD",          "AVX-512 Conflict Detection");
if_("AVX512ER",          "AVX-512 Exponential and Reciprocal");
if_("AVX512PF",          "AVX-512 Prefetch");
if_("MPX",               "MPX");
if_("SHA",               "SHA");
if_("PREFETCHWT1",       "PREFETCHWT1");
if_("AVX512VL",          "AVX-512 Vector Length Orthogonality");
if_("AVX512DQ",          "AVX-512 Dword and Qword");
if_("AVX512BW",          "AVX-512 Byte and Word");
if_("AVX512IFMA",        "AVX-512 IFMA instructions");
if_("AVX512VBMI",        "AVX-512 VBMI instructions");
if_("AES",               "AES instructions");
if_("VAES",              "AES AVX instructions");
if_("VPCLMULQDQ",        "AVX Carryless Multiplication");
if_("GFNI",              "Galois Field instructions");
if_("AVX512VBMI2",       "AVX-512 VBMI2 instructions");
if_("AVX512VNNI",        "AVX-512 VNNI instructions");
if_("AVX512BITALG",      "AVX-512 Bit Algorithm instructions");
if_("AVX512VPOPCNTDQ",   "AVX-512 VPOPCNTD/VPOPCNTQ");
if_("AVX5124FMAPS",      "AVX-512 4-iteration multiply-add");
if_("AVX5124VNNIW",      "AVX-512 4-iteration dot product");
if_("AVX512FP16",        "AVX-512 FP16 instructions");
if_("AVX512FC16",        "AVX-512 FC16 instructions");
if_("SGX",               "Intel Software Guard Extensions (SGX)");
if_("CET",               "Intel Control-Flow Enforcement Technology (CET)");
if_("ENQCMD",            "Enqueue command instructions");
if_("PCONFIG",           "Platform configuration instruction");
if_("WBNOINVD",          "Writeback and do not invalidate instruction");
if_("TSXLDTRK",          "TSX suspend load address tracking");
if_("SERIALIZE",         "SERIALIZE instruction");
if_("AVX512BF16",        "AVX-512 bfloat16");
if_("AVX512VP2INTERSECT", "AVX-512 VP2INTERSECT instructions");
if_("AMXTILE",           "AMX tile configuration instructions");
if_("AMXBF16",           "AMX bfloat16 multiplication");
if_("AMXINT8",           "AMX 8-bit integer multiplication");
if_("FRED",              "Flexible Return and Exception Delivery (FRED)");
if_("RAOINT",		 "Remote atomic operations (RAO-INT)");
if_("UINTR",		 "User interrupts");
if_("CMPCCXADD",         "CMPccXADD instructions");
if_("PREFETCHI",         "PREFETCHI0 and PREFETCHI1");
if_("WRMSRNS",		 "WRMSRNS");
if_("MSRLIST",           "RDMSRLIST and WRMSRLIST");
if_("AVXNECONVERT",	 "AVX exceptionless floating-point conversions");
if_("AVXVNNIINT8",       "AVX Vector Neural Network 8-bit integer instructions");
if_("AVXIFMA",           "AVX integer multiply and add");
if_("HRESET",            "History reset");

if_("OBSOLETE",          "Instruction removed from architecture");
if_("NEVER",             "Instruction never implemented");
if_("NOP",               "Instruction is always a (nonintentional) NOP");
if_("VEX",               "VEX or XOP encoded instruction");
if_("EVEX",              "EVEX encoded instruction");

if_("8086",              "8086");
if_("186",               "186+");
if_("286",               "286+");
if_("386",               "386+");
if_("486",               "486+");
if_("PENT",              "Pentium");
if_("P6",                "P6");
if_("KATMAI",            "Katmai");
if_("WILLAMETTE",        "Willamette");
if_("PRESCOTT",          "Prescott");
if_("X86_64",            "x86-64 (long or legacy mode)");
if_("NEHALEM",           "Nehalem");
if_("WESTMERE",          "Westmere");
if_("SANDYBRIDGE",       "Sandy Bridge");
if_("FUTURE",            "Ivy Bridge or newer");
if_("IA64",              "IA64 (in x86 mode)");

# Default CPU level
if_("DEFAULT",           "Default CPU level");

# Must be the last CPU definition
if_("ANY",               "Allow any known instruction");

# These must come after the CPU definitions proper
if_("CYRIX",             "Cyrix-specific");
if_("AMD",               "AMD-specific");




- Operands starting with 'sbyte' can be ignored. They are imm16/32/64 that can fit into smaller widths.
- OPT is only used 6 times, and only for alternative operands, can be omitted
- ND seems to only be used for alternative forms? Used many times, probably can't be omitted for most cases
	- Used for FADD/FMUL void forms
	- Used for imm variances (sbyte, etc.)
	- Can be ignored when paired with certain operands
	- 'Not Documented'? Used for encodings that don't exactly match the Intel Manual
	- Used for all KMOV instructions (Intel Manual uses KMOVB, KMOVD, etc., NASM only uses KMOV)
	- Seems to be used for alias instructions (can be omitted)
- VEX, EVEX, DEFAULT, ANY, NOP: Never used
- HLE: Used once (XTEST)
- NOHLE: Only used with MOV MOFFS (4 times)
- SIB: Only used with AMXTILE (3 times)
- MIB: Used 12 times (AMXTILE, MPX)
- iwdq: Only used with MOV moffs
- AR3, AR4: Never used
- AR0: Only used with PUSH (8 times)
- AR1: Used 30 times
- AR2: Used 35 times
- ANYSIZE: Only used with LEA (6 times)
- SIZE: Only used with PUSH IMM (8 times)
- LATEVEX: Used 30 times. Obsolete instructions? They don't appear in the Intel manual, can be omitted?
- vm32x/vm32y: Only used with VGATHER... (8 times)
- vm64x/vm64y: Only used VGATHER... (8 times)
- vm32z/vm64z: Never used
- vsibx/vsiby/vsibz: Used 64 times
- wait: Only used with FPU instructions (10 times), insert 9B before opcode
- hlexr: Only used with MOV (12 times)
- nohi: Only used twice, can be omitted
- SM2: Only used with encodings with 3 operands (IMUL, SHLD, SHRD, PSHUFxx, 20 times)
- SM: Only used with encoding with 2 operands, used many times
- SX: Only used with AMXTILE (3 times, excluding ND and LATEVEX instructions)
- Unsized memory operands must not take a width (e.g. SGDT)
- f2i: Only used with CRC32 (5 times), just add f2 to the front of the opcode?
- f3i: Only used 10 times, just add f3 to the front of the opcode?
- ERROR? PMULUDQ and PSUBQ with MMX registers should be SQ not SO
- ERROR? PSHUFW/PSHUFD/PSHUFHW/PSHUFLW/PALIGNR with explicit memory width causes error
- ERROR? Intel manual gives tuple type for VEX instruction VCVTTSD2SI

- If prefix (66, F2, F3), escape (0F, 0F 38, 0F 3A) and wait (9B) are removed, then opcodes don't exceed 2 bytes
	- 5 FPU instructions start with 9B and have two other opcode bytes
	- These are marked as having a 'wait' prefix
	- 9B DB E2  FCLEX
	- 9B DB E1  FDISI
	- 9B DB E0  FENI
	- 9B DB E3  FINIT
	- 9B DD/6   FSAVE   MEM
	- 9B D9/7   FSTCW   MEM
	- 9B D9/6   FSTENV  MEM
	- 9B DD/7   FSTSW   MEM
	- 9B DF E0  FSTSW   AX
	- 9B        FWAIT
	- The 'wait' prefix is actually a prefix and not part of the opcodef, since it comes before the REX prefix
- Some psuedo-encodings have an additional byte after MODRM

ENCODINGS:
mr      Many uses
rm      Many uses
mi      Many uses
-i      43, e.g. AX_I8
m       Many uses
r       53
r-      28, FPU (ST_ST0)
-r      28, FPU (ST0_ST)
-       17, un-encoded single operand (AX)
rmi     Many uses
r+mi    12, Only used by IMUL R_I (undocumented)
i       81
i-      23, imm with un-encoded second operand (I8_AX)
m-      78, mem with un-encoded second operand (M_CL)
mri     86
mr-     12, SHLD, SHRD (M_R_CL)
rvm     Many uses
rvmi    Many uses
rvms    53, AVX
mvr     12, Only used by AVX512
vmi     69
rmv     44
vm      24, Only used by BMI1 and TBM
rmx     1, Only used by BND
mxr     1, Only used by BND
mrx     1, Only used by BND
rmvi    Many uses

TUPLE TYPES:
fv
t1s
t2
t4
t8
hv
hvm
t1f64
t1f32
fvm
dup
t1s8
t1s16
qvm
ovm
m128

Common : nds, 128, 256, 0f38, 0f3a, 0f, wig, lig, f2, f3, w0, w1, np
VEX    : lz, ndd, dds, l1, l0
EVEX   : map5, map6, 512


// R_M for MMX/SSE appears 4 times:
F2 0F 2D  CVTSD2SI   R_XM64   1100
F3 0F 2D  CVTSS2SI   R_XM32   1100
F2 0F 2C  CVTTSD2SI  R_XM64   1100
F3 0F 2C  CVTTSS2SI  R_XM32   1100

ERROR: PTWRITE is missing F3 prefix
ERROR: SETcc has /0, but should have no extension?

E.NP.3A.W0 66  VFPCLASSPH  K_SMB16_I8  full
E.66.3A.W0 66  VFPCLASSPS  K_SMB32_I8  full
E.66.3A.W1 66  VFPCLASSPD  K_SMB64_I8  full
E.NP.3A.W0 67  VFPCLASSSH  K_XM16_I8   scalar
E.66.3A.W0 67  VFPCLASSSS  K_XM32_I8   t1scalar
E.66.3A.W1 67  VFPCLASSSD  K_XM64_I8   t1scalar

V.66.38.W1 92  VGATHERDPD  S_VM32X_S
V.66.38.W1 93  VGATHERQPD  S_VM64S_S
V.66.38.W0 92  VGATHERDPS  S_VM32S_S
V.66.38.W0 93  VGATHERQPS  S_VM64S_S
E.66.38.W0 92  VGATHERDPS  S_VM32S   vsib