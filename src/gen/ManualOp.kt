package eyre.gen

import eyre.Mnemonic.*

enum class ManualOp(
	val first: ManualOp? = null,
	val second: ManualOp? = null,
	val widths: Array<ManualOp>? = null,
	val isAmbiguous: Boolean = false,
) {
	NONE,

	R8,
	R16,
	R32,
	R64,
	M8,
	M16,
	M32,
	M64,
	M80,
	M128,
	M256,
	M512,
	MEM,
	MM,
	X,
	Y,
	DX(isAmbiguous = true),
	CL(isAmbiguous = true),
	AL(isAmbiguous = true),
	AX(isAmbiguous = true),
	EAX(isAmbiguous = true),
	RAX(isAmbiguous = true),
	I8,
	I16(isAmbiguous = true),
	I32(isAmbiguous = true),
	I64(isAmbiguous = true),
	REL8(isAmbiguous = true),
	REL32(isAmbiguous = true),
	FS(isAmbiguous = true),
	GS(isAmbiguous = true),
	SEG(isAmbiguous = true),
	MOF(isAmbiguous = true),
	CR(isAmbiguous = true),
	DR(isAmbiguous = true),
	ONE(isAmbiguous = true),
	ST(isAmbiguous = true),
	ST0(isAmbiguous = true),
	VM32X,
	VM64X,
	VM32Y,
	VM64Y,

	// Width multi ops
	A(widths = arrayOf(AL, AX, EAX, RAX), isAmbiguous = true),
	R(widths = arrayOf(R8, R16, R32, R64)),
	M(widths = arrayOf(M8, M16, M32, M64)),
	I(widths = arrayOf(I8, I16, I32, I32), isAmbiguous = true),

	// Multi ops
	RM(R, M),
	XM(X, M128),
	YM(Y, M256),
	MMM(MM, M64),
	RM8(R8, M8),
	RM16(R16, M16),
	RM32(R32, M32),
	RM64(R64, M64),
	MMM64(MM, M64),
	XM8(X, M8),
	XM16(X, M16),
	XM32(X, M32),
	XM64(X, M64),
	XM128(X, M128),
	YM8(Y, M8),
	YM16(Y, M16),
	YM32(Y, M32),
	YM64(Y, M64),
	YM128(Y, M128),
	YM256(Y, M256);

}